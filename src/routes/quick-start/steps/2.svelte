<script lang="ts">
	import { generateNewData } from '$lib/generate_data';
	import { performPCA } from '$lib/pca';
	import { processedData, setupInformation, unprocessedData } from '$lib/stores';
	import { type TableSource, Table } from '@skeletonlabs/skeleton';
	import { onDestroy } from 'svelte';
	import type { Unsubscriber } from 'svelte/store';

	export let dataCreated: boolean = false;

    const rawData: TableSource = {
        head: [],
        body: []
    };

    const latentData: TableSource = {
        head: [],
        body: []
    };

	function generateData() {
        generateNewData();
        performPCA($unprocessedData, $setupInformation);
		dataCreated = true;
	}

    const unSub: Unsubscriber = processedData.subscribe(data=>{
        const currentIndex = 3;

        if(data.expectedData[currentIndex]){
            rawData.head = [];
            latentData.head = [];
            for (let i=0; i<data.expectedData[currentIndex].length; i++) {
                rawData.head.push("Component " + (i+1).toString());
                latentData.head.push("Component " + (i+1).toString());
            }
            rawData.body = [data.expectedData[currentIndex].map(value => (Math.round((value) * 100) / 100).toString())];
            latentData.body = [$unprocessedData.expectedData[currentIndex].map(value => (Math.round((value) * 100) / 100).toString())];
        }
    });

    onDestroy(() => {
        unSub();
    });

</script>

<h4 class="h4 my-6 mx-3">
	Use the button below to generate some test data. This data contains 950 rows and 100 columns
	of what we call 'regular' data. This data is generated by sampling from the same distribution for
	each column. Additionally, 50 rows with 100 columns are generated completely randomly, we call this 'irregular'
	data. We now have high dimensional data. The goal of our app is to find the irregular data using
	only sound!
</h4>

<div class="my-10 w-[80%] mx-auto flex justify-center items-stretch flex-wrap">
	<div class="flex-col flex justify-center items-center flex-1">
		<button
			type="button"
			class="btn {dataCreated
				? 'variant-filled-success'
				: 'variant-filled-tertiary'} !rounded-full h6 my-1"
			on:click={generateData}
		>
			Generate Data
		</button>
		<span
			class="divider-vertical h-5 my-1 border {dataCreated
				? 'border-success-500'
				: 'border-tertiary-500'}"
		/>
		<p class="h6 {dataCreated ? 'text-success-500 font-semibold' : 'text-error-500'} ">
			Performed dimensionality reduction
		</p>
	</div>
	<span class="divider-vertical divider-tertiary-500 min-h-full" />
	<div class="flex-col flex justify-center items-center flex-1 text-right">
		<h6 class="my-2 h6">Example row from generated data:</h6>
        {#if dataCreated}
            <Table source={rawData} class="max-w-lg overflow-auto"/>
        {/if}
		<h6 class="my-2 h6">Latent representation after dimensionality reduction:</h6>
        {#if dataCreated}
            <Table source={latentData} class="max-w-lg overflow-auto"/>
        {/if}
	</div>
</div>

<h5 class="h5 my-6 mx-3">
	Dimensionality reduction is perfomed automatically on generated data. Dimensionality reduction calculates a new set of
	variables to represent the original data which is more compact while retaining its essential
	features. The resultant lower-dimensional representation helps in understanding complex data
	structures and patterns by focusing on the most informative aspects of the data. In our case, we
	use principle component analysis which sorts the calculated variables in order variance
	captured.
</h5>
